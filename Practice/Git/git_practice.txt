*выполнение различных команд одна за одной выполняется вводом команд и их отделением знаком ; (пример: git fetch; git branch; и т.д.)
- создание локального репозитория (git init (создает репозиторий в выбранном каталоге), git clone <ссылка на удаленный репозиторий> <имя для локального репозитория> (создает копию удаленного репозитория со своим именем (имя можно не вводить)))
- удаление локального репозитория (удалить папку)
- просмотр удаленных репозиториев (git remote); добавить -v, чтобы просмотреть адреса для чтения и записи; просмотр детальной информации об удаленном репозитории (git remote show <shortname_remote_repo>)
- добавление удаленных репозиториев (git remote add <shortname_remote_repo> <ссылка на удаленный репозиторий>)
	*если в отслеживаемых репозиториях будут ветки с одним и тем же названием, то нормально работать можно будет только с одной из них
	*по умолчанию ветки из добавленных отслеживаемых репозиториев не добавляются в локальный репозиторий, для их добавления нужно просто переключиться на необходимую ветку (git switch <name_branch> или git checkout <name_branch>)
- переименование удаленного репозитория (git remote rename <old_shortname_remote_repo> <new_shortname_remote_repo>) (переименование идет для локального гита, а не для удаленного)
- удаление удаленного репозитория (git remote remove <shortname_remote_repo>) (сам удаленный репозиторий не удалится, просто перестанет отслеживаться локально)

- вывести все или определенные параметры конфига (git config --list, git config <имя определенного параметра>)

- узнать статус репозитория (git status, добавить -s для сокращенного вывода статуса)
- начать отслеживать новый файл (git add <name_file>)
- выполнить индексацию (git add <name_file>, git add . (индексация всех изменений)), выполнить частичную индексацию файлов (git add -p), интерактивное индексирование (add -i)
- просмотр неиндексированных изменений (git diff), просмотр индексированных изменений (git diff --staged или --cached)
- отмена неиндексированных изменений (git restore <name_file>), отмена индексированных изменений (git restore --staged <name_file>)
- припрятывание индексированных и неиндексированных изменений (git stash), вывод списка припрятанных изменений (git stash list)
	припрятать изменения, но оставить проиндексированные изменения (--keep-index), припрятать также неотслеживаемые файлы (-u)
	припрятать также неотслеживаемые и игнорируемые файлы (-a), припрятать только выбранные изменения (-p)
	применить припрятанные изменения (git stash apply <не добавлять ничего, тогда примениться последние припрятанное изменение> или <name_stash>)
	*по умолчанию все припрятанные изменения восстанавливаются как неиндексированные изменения
	применить припрятанные изменения как индексированные изменения (добавятся, если до припрятывания изменения были индексированы) (--index)
	удалить припрятанные изменения (git stash drop <name_stash>), применить последние припрятанные изменения и тут же удалить их (git stash pop)
	создание ветки из последних припрятанных изменений (git stash branch <name_branch>)
	* создаст новую ветку, перейдёт на коммит, на котором вы были, когда прятали свои наработки, применит на нём эти наработки и затем, если они применились успешно, удалит эти припрятанные изменения
- удаление файлов из репозитория (вручную удалить из папки или через git rm <name_file>); для удаления измененного файла добавить -f; удалить файл из репозитория, но оставить его на жестком диске (добавить --cached)
- удаление неотслеживаемых файлов (clean -f); добавить -x для удаления неотслеживаемых и игнорируемых файлов; добавить -d для удаления оставшихся пустых каталогов; добавить -n, чтобы узнать, что будет удалено; добавить -i для перехода в интерактивный режим
	*более безопасным вариантом является использование команды git stash -u для удаления неотслеживаемых файлов или git stash -a для удаления неотслеживаемых и игнорируемых файлов, но с сохранением этого в виде припрятанных изменений
- переименование файлов вручную через папку или через git mv <old_name_file> <new_name_file>

- провести коммит (git commit), добавить сообщение через открывшийся блокнот или через -m "<текст сообщения>", игнорирование индексации при выполнении коммита (-a)
- изменение сообщения последнего коммита и/или добавление индексированных изменений в предыдущий коммит (git commit --amend) (в этом случае перезапишется последний коммит, а не создастся новый); добавить --no-edit, если не нужно изменять сообщение к коммиту
	*делать только в случае, если история не пострадает (например исправление опечатки, исправление сообщения коммита, добавление отслеживаемого файла и т.д.)
	*не делать --amend в опубликованную ветку (если коммит уже опубликован, то нужно делать новый коммит, -- amend нужно использовать только для изменений неопубликованных коммитов в локальном репозитории)

- получить изменения с удаленного репозитория на локальный (git fetch); получить изменения с определенного удаленного репозитория на локальный (тот, который синхронизирован с определенным удаленным репозиторием, а не текущим) (git fetch <shortname_remote_repo>)
	*команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.
- замержить текущую ветку с другой веткой (git merge <name_local_branch> или <shortname_remote_repo>/<name_remote_branch>)
	*если при слиянии появится конфликт, то можно вернуть ветку в исходное до слияния состояние (merge --abort)
- объединить все коммиты из тематической ветки (которые идут после родительского коммита) в один коммит в текущей ветке (git merge <topicbranch> --squash), после чего все изменения коммитов будут находиться в индексе, необходимо провести коммит для создания одного коммита со всеми изменениями
	*использовать для объединения маленьких коммитов с незначительными изменениями (добавление заголовка, исправление опечатки и т.д.)
- автоматически получить изменения из удалённой ветки и слить их со своей текущей веткой (git pull); автоматически получить изменения из определенной удалённой ветки в указанную локальную ветку (git pull <shortname_remote_repo> или <url_repo> <name_remote_branch>:<name_local_branch> or <name_new_branch>)
- внести изменения из текущей локальной ветки в удаленную ветку (git push); внести изменения из указанной локальной ветки в определенную удалённую ветку (push <shortname_remote_repo> или <url_repo> <name_local_branch>:<name_remote_branch> or <name_new_branch>)

- создать новую ветку из копии текущей ветки (git branch <new_branch_name>); создать новую ветку из копии определенной ветки (git branch <new_branch_name> <shortname_remote_repo>/<name_branch>); добавить флаг -c или -b для автоматического переключения на новую созданную ветку (switch -c или checkout -b)
	*перед созданием ветки, источником которой является удаленная ветка, нужно выполнить команду fetch (для обновления данных с сервера)
- переключиться на другую ветку (git switch <name_branch> или git checkout <name_branch>); переключиться на предыдущую ветку (git switch - или git checkout -)
- вывести список локальных веток (git branch); добавить --all для вывода удаленных веток
	вывод замерженных веток относительно текущей ветки (git branch --merged), вывод незамерженных веток относительно текущей ветки (git branch --no-merged); добавить <name_branch>, если нужно посмотреть относительно другой указанной ветки
	*замерженные ветки можно спокойно удалять, незамерженные ветки можно удалить только через флаг -D
- добавить локальную ветку в удаленный репозиторий и начать ее отслеживать (git push -u <shortname_remote_repo> <name_branch>)
- добавление к локальной ветке слежение за удаленной веткой (перейти на необходимую локальную ветку и выполнить команду git branch -u <shortname_remote_repo>/<name_remote_branch>)
	*необходимо, чтобы названия были одинаковыми в локальной и удаленной ветке
- переименование ветки в локальном репозитории (git branch --move <old_name_branch> <new_name_branch>), после чего нужно запушить ветку на удаленный репозиторий (с флагом -u) и удалить удаленную ветку со старым названием;
	переименование удаленной ветки проводить через удаленный репозиторий, после чего выполнить git fetch, переключиться на ветку с новым названием и удалить локальную ветку со старым названием
	*не переименовывайте ветки, которые всё ещё используются другими участниками
	*не переименовывайте ветку в master/main/mainline, не прочитав раздел «Изменение имени главной ветки»
- удаление локальной ветки (git branch -d <name_branch>)
- удаление удаленной ветки (git push <shortname_remote_repo> -d <name_remote_branch>)

- просмотр изменений текущей ветки (git log); просмотр изменений определенной ветки (git log <name_branch>); просмотр изменений всех веток (git log --all)
	добавление -p показывает изменения, внесённые в каждый коммит; количество выводимых коммитов (-<цифра>); вывод сокращенной статистики для коммитов (--stat); вывод коммитов с определенным автором (--author <name_author>); вывод коммитов с определенным коммитером (--committer <name_committer>);
	вывод коммитов с определенным сообщением (--grep <текст_сообщения>); добавление -S <текст_строки> показывает коммиты, в которых изменение повлекло за собой добавление или удаление указанной строки; вывести лог записей из reflog (-g)
	добавление -- <name_file> или path/to/file выводит коммиты, где изменялся указанный файл (вводится в самом конце, *после двойного тире должен быть пробел))
- посмотреть, на каком коммите ранее находился указатель HEAD (git reflog)
- вывести последние коммиты у всех локальных веток (с дополнительной информацией о том, какая из веток отслеживается, отстаёт, опережает или всё сразу относительно отслеживаемой ветки) (git branch -v или -vv); добавить --all для вывода удаленных веток
- просмотр подробных сведений о последнем коммите (git show), просмотр подробных сведений об определенном коммите (git show <SHA>)
- определить коммит и автора определенной строки (git blame -L <номер первой строки>,<номер последней строки> <name_file>)

- получить версии файлов определенного коммита (git switch <SHA> --detach или git checkout <SHA>)
	*если необходимо работать с файлами определенного коммита, то нужно создать новую ветку и работать в ней
	
- провести перебазирование (git rebase <base_branch> или <SHA>), выполнить перебазирование ветки <topic_branch> относительно ветки <base_branch> без предварительного переключения на неё (git rebase <base_branch> или <SHA> <topic_branch>)
	*лучше всегда делать перебазирование на последний коммит ветки, чтобы не было путаницы
	*перед перебазированием лучше принять новые изменения с удаленного репозитория для <base_branch>
	*не делать rebase в опубликованной ветке, лучше использовать rebase в локальной тематической ветке
	*при решении конфликтов нужно добавить изменения в индекс и провести команду git rebase --continue; если изменения в предложенном коммите вообще не нужны, то нужно провести команду git rebase --skip; для отмены перебазирования нужно провести команду git rebase --abort
	передать коммиты ветки <topic_topic_branch> в качестве оснований для перебазирования (git rebase --onto <base_branch> <topic_branch> <topic_topic_branch>)
	*в этой команде говорится: "Переключись на ветку <base_branch>, найди изменения относительно ветки <topic_branch> и примени их для ветки <topic_topic_branch>"
	*родительский коммит ветки <topic_topic_branch> в этом случае перебазироваться не будет, будет перебазироваться только то, что идет после него
- выборочно применить коммит из тематической ветки к текущей ветке (git cherry-pick <SHA>) (будет создан коммит с другим SHA);
	добавление --edit позволит поменять сообщение коммита; добавление --no-commit перенесет изменения выбранного коммита в индексированные изменения в текущей ветке (новый коммит создан не будет)
	
- переместиться на указанный коммит с неиндексированными изменениями (git reset <SHA>), коммиты, которые были внесены после указанного коммита пропадут из истории, все изменения исчезнувших коммитов перенесутся в неиндексированные изменения
	добавить --soft для переноса изменений в индексированные изменения; добавить --hard для перемещения на указанный коммит без сохранения изменений
	*не использовать reset в опубликованных ветках
	*чаще всего reset нужен для объединения нескольких небольших коммитов в один или для удаления ненужных коммитов
	*если понадобятся коммиты, удаленные из истории, то их можно найти через команду git reflog или git log -g
	
- отмена изменений последнего коммита и создание нового коммита с отмененными изменениями (git revert HEAD), отмена изменений до определенного коммита (включая отмену изменений указанного коммита) и создание нового коммита с отмененными изменениями (git revert <SHA>) (в этом случае будет конфликт)
	*при добавлении флага -n новый коммит создаваться не будет, вместо этого отмененные изменения будут добавлены в индексированные изменения
	*при решении конфликтов нужно добавить изменения в индекс и провести команду git revert --continue; для отмены git revert нужно провести команду git revert --abort
	*после отмены изменений коммита история не изменится, в истории появится новый коммит с отмененными изменениями; замержить отмененные изменения будет нельзя, т.к. Git будет считать, что эти изменения уже есть в истории и их не нужно вносить
	*данную команду лучше использовать для удаленного репозитория, т.к. в ней важно сохранить достоверную историю